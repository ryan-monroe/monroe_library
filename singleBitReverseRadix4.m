function singleBitReverseRadix4(reoLen)
% This is a generated function based on subsystem:
%     single_bit_rev_test/single_bit_reverse
% Though there are limitations about the generated script, 
% the main purpose of this utility is to make learning
% Sysgen Script easier.
% 
% To test it, run the following commands from MATLAB console:
% cfg.source = str2func('single_bit_reverse');
% cfg.toplevel = 'single_bit_rev_test/single_bit_reverse';
% args = {my_reoLen};
% xBlock(cfg, args);
% 
% You can edit single_bit_reverse.m to debug your script.
% 
% You can also replace the MaskInitialization code with the 
% following commands so the subsystem will be generated 
% according to the values of mask parameters.
% cfg.source = str2func('single_bit_reverse');
% cfg.toplevel = gcb;
% args = {reoLen};
% xBlock(cfg, args);
% 
% To configure the xBlock call in debug mode, in which mode,
% autolayout will be performed every time a block is added,
% run the following commands:
% cfg.source = str2func('single_bit_reverse');
% cfg.toplevel = gcb;
% cfg.debug = 1;
% args = {reoLen};
% xBlock(cfg, args);
% 
% To make the xBlock smart so it won't re-generate the
% subsystem if neither the arguments nor the scripts are
% changes, use as the following:
% cfg.source = str2func('single_bit_reverse');
% cfg.toplevel = gcb;
% cfg.depend = {'single_bit_reverse'};
% args = {reoLen};
% xBlock(cfg, args);
% 
% See also xBlock, xInport, xOutport, xSignal, xlsub2script.
% xBlock;
% reoLen=8;

assert(isInt(reoLen/2),'radix 4 reorder must have power-of-4 reorder length!');

%% inports
xlsub2_sync = xInport('sync');
xlsub2_din0 = xInport('din');

%% outports
xlsub2_sync_out = xOutport('sync_out');
xlsub2_dout0 = xOutport('dout');

%% diagram
% 
% % block: single_bit_rev_test/single_bit_reverse/Concat2
% xlsub2_Constant5_out1 = xSignal('xlsub2_Constant5_out1');
xlsub2_Mux_out1 = xSignal('xlsub2_Mux_out1');
% xlsub2_Concat2_out1 = xSignal('xlsub2_Concat2_out1');
% xlsub2_Concat2 = xBlock(struct('source', 'Concat', 'name', 'Concat2'), ...
%                         [], ...
%                         {xlsub2_Constant5_out1, xlsub2_Mux_out1}, ...
%                         {xlsub2_Concat2_out1});

% block: single_bit_rev_test/single_bit_reverse/Constant
xlsub2_Constant_out1 = xSignal('xlsub2_Constant_out1');
xlsub2_Constant = xBlock(struct('source', 'Constant', 'name', 'Constant'), ...
                         struct('arith_type', 'Boolean', ...
                                'n_bits', 1, ...
                                'bin_pt', 0, ...
                                'explicit_period', 'on'), ...
                         {}, ...
                         {xlsub2_Constant_out1});
% 
% % block: single_bit_rev_test/single_bit_reverse/Constant5
% xlsub2_Constant5 = xBlock(struct('source', 'Constant', 'name', 'Constant5'), ...
%                           struct('arith_type', 'Boolean', ...
%                                  'n_bits', 1, ...
%                                  'bin_pt', 0, ...
%                                  'explicit_period', 'on'), ...
%                           {}, ...
%                           {xlsub2_Constant5_out1});

% block: single_bit_rev_test/single_bit_reverse/Counter
xlsub2_Counter_out1 = xSignal('xlsub2_Counter_out1');
xlsub2_Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
                        struct('cnt_to', 1023, ...
                               'start_count', 0, ...
                               'n_bits', reoLen+1, ...
                               'rst', 'on', ...
                               'use_rpm', 'off'), ...
                        {xlsub2_sync}, ...
                        {xlsub2_Counter_out1});

% block: single_bit_rev_test/single_bit_reverse/Mux
xlsub2_Slice1_out1 = xSignal('xlsub2_Slice1_out1');
xlsub2_Slice2_out1 = xSignal('xlsub2_Slice2_out1');
xlsub2_bit_reverse_1_out1 = xSignal('xlsub2_bit_reverse_1_out1');
xlsub2_Mux = xBlock(struct('source', 'Mux', 'name', 'Mux'), ...
                    [], ...
                    {xlsub2_Slice1_out1, xlsub2_Slice2_out1, xlsub2_bit_reverse_1_out1}, ...
                    {xlsub2_Mux_out1});

% block: single_bit_rev_test/single_bit_reverse/Single Port RAM
xlsub2_Single_Port_RAM = xBlock(struct('source', 'Single Port RAM', 'name', 'Single Port RAM'), ...
                                struct('depth', 2^reoLen, ...
                                       'write_mode', 'Read Before Write', ...
                                       'latency', 2), ...
                                {xlsub2_Mux_out1, xlsub2_din0, xlsub2_Constant_out1}, ...
                                {xlsub2_dout0});

% block: single_bit_rev_test/single_bit_reverse/Slice1
xlsub2_Slice1 = xBlock(struct('source', 'Slice', 'name', 'Slice1'), ...
                       [], ...
                       {xlsub2_Counter_out1}, ...
                       {xlsub2_Slice1_out1});

% block: single_bit_rev_test/single_bit_reverse/Slice2
xlsub2_Slice2 = xBlock(struct('source', 'Slice', 'name', 'Slice2'), ...
                       struct('nbits', reoLen, ...
                              'mode', 'Lower Bit Location + Width'), ...
                       {xlsub2_Counter_out1}, ...
                       {xlsub2_Slice2_out1});

% block: single_bit_rev_test/single_bit_reverse/post_sync_delay
xlsub2_sync_delay_fast_out1 = xSignal('xlsub2_sync_delay_fast_out1');
xlsub2_post_sync_delay = xBlock(struct('source', 'Delay', 'name', 'post_sync_delay'), ...
                                struct('latency', 2), ...
                                {xlsub2_sync_delay_fast_out1}, ...
                                {xlsub2_sync_out});

% block: single_bit_rev_test/single_bit_reverse/sync_delay_fast
xlsub2_sync_delay_fast = xBlock(struct('source', 'monroe_library/sync_delay_fast', 'name', 'sync_delay_fast'), ...
                                struct('delay_len', 2^reoLen), ...
                                {xlsub2_sync}, ...
                                {xlsub2_sync_delay_fast_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1

xlsub3_bit_reverse_sub = xBlock(struct('source', str2func('bit_reverse_draw_v2'), 'name','bit_reverse_radix4'), {reoLen,true});
%xlsub3_bit_reverse_sub = xlsub3_bit_reverse(FFTSize-1);
xlsub3_bit_reverse_sub.bindPort({xlsub2_Slice2_out1}, {xlsub2_bit_reverse_1_out1});
% 
% xlsub2_bit_reverse_1_sub = xBlock(struct('source', @xlsub2_bit_reverse_1, 'name', 'bit_reverse_1'), ...
%                               {}, ...
%                               {xlsub2_Slice2_out1}, ...
%                               {xlsub2_bit_reverse_1_out1});



function xlsub2_bit_reverse_1()



%% inports
xlsub3_in = xInport('in');

%% outports
xlsub3_out = xOutport('out');

%% diagram

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/concat
xlsub3_slice7_out1 = xSignal('xlsub3_slice7_out1');
xlsub3_slice6_out1 = xSignal('xlsub3_slice6_out1');
xlsub3_slice5_out1 = xSignal('xlsub3_slice5_out1');
xlsub3_slice4_out1 = xSignal('xlsub3_slice4_out1');
xlsub3_slice3_out1 = xSignal('xlsub3_slice3_out1');
xlsub3_slice2_out1 = xSignal('xlsub3_slice2_out1');
xlsub3_slice1_out1 = xSignal('xlsub3_slice1_out1');
xlsub3_concat = xBlock(struct('source', 'Concat', 'name', 'concat'), ...
                       struct('num_inputs', 7), ...
                       {xlsub3_slice7_out1, xlsub3_slice6_out1, xlsub3_slice5_out1, xlsub3_slice4_out1, xlsub3_slice3_out1, xlsub3_slice2_out1, xlsub3_slice1_out1}, ...
                       {xlsub3_out});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice1
xlsub3_slice1 = xBlock(struct('source', 'Slice', 'name', 'slice1'), ...
                       struct('boolean_output', 'on', ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice1_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice2
xlsub3_slice2 = xBlock(struct('source', 'Slice', 'name', 'slice2'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -1, ...
                              'bit0', -1, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice2_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice3
xlsub3_slice3 = xBlock(struct('source', 'Slice', 'name', 'slice3'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -2, ...
                              'bit0', -2, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice3_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice4
xlsub3_slice4 = xBlock(struct('source', 'Slice', 'name', 'slice4'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -3, ...
                              'bit0', -3, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice4_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice5
xlsub3_slice5 = xBlock(struct('source', 'Slice', 'name', 'slice5'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -4, ...
                              'bit0', -4, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice5_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice6
xlsub3_slice6 = xBlock(struct('source', 'Slice', 'name', 'slice6'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -5, ...
                              'bit0', -5, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice6_out1});

% block: single_bit_rev_test/single_bit_reverse/bit_reverse_1/slice7
xlsub3_slice7 = xBlock(struct('source', 'Slice', 'name', 'slice7'), ...
                       struct('boolean_output', 'on', ...
                              'bit1', -6, ...
                              'bit0', -6, ...
                              'base0', 'MSB of Input'), ...
                       {xlsub3_in}, ...
                       {xlsub3_slice7_out1});



end

end

